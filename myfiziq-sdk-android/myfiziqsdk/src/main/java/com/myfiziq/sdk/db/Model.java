package com.myfiziq.sdk.db;

import android.annotation.SuppressLint;
import android.content.ContentValues;
import android.database.Cursor;
import android.os.Parcel;
import android.os.Parcelable;
import android.text.TextUtils;
import android.util.Base64;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParseException;
import com.google.gson.JsonParser;

import org.apache.commons.lang3.ArrayUtils;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.lang.reflect.WildcardType;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.UUID;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;
import timber.log.Timber;

/**
 * The base <code>Model</code> class for a database type.
 */
public class Model implements Parcelable
{
    public static final int DEFAULT_DEPTH = 5;

    public static final String COLUMN_ID = "id";
    public static final String COLUMN_PRIMARY_KEY = "pk";
    public static final String COLUMN_TIMESTAMP = "ts";

    @Persistent(appDb = "PRIMARY KEY AUTOINCREMENT", pk = true, serialize = false)
    public long pk = Long.valueOf(0);

    @Persistent(serialize = false)
    public String id = "";

    @Persistent(serialize = false)
    public boolean deleted = false;

    @Persistent(serialize = false)
    public Timestamp ts = new Timestamp();

    @Override
    public int describeContents()
    {
        return 0;
    }

    /**
     * Returns the 'id' field.
     *
     * @return id.
     */
    public String getId()
    {
        return id;
    }

    /**
     * Returns the table and field name for the 'id' column.
     *
     * @return modelName + id.
     */
    public String getIdFieldName()
    {
        return getModelName() + ".id";
    }

    /**
     * Returns the table and field name for the 'id' column of the specified model.
     *
     * @return modelName + id.
     */
    public static String getIdFieldName(Class clazz)
    {
        return Orm.getModelName(clazz) + ".id";
    }

    /**
     * Sets the primary key field value.
     * <br>
     * Generally this is automatically generated by the database.
     *
     * @param pkVal - The pk.
     */
    public void setPk(long pkVal)
    {
        pk = pkVal;
    }

    /**
     * Returns a string representing the "order by" part of the query or null for no order.
     *
     * @param limit - an optional limit of items for the query.
     * @return
     */
    public static String getOrderBy(int limit)
    {
        return null;
    }

    public void initId()
    {
        if (TextUtils.isEmpty(id))
        {
            id = newId();
        }
    }

    public Model()
    {

    }

    public String getModelName()
    {
        return Orm.getModelName(getClass());
    }

    public Model(Parcel parcelData)
    {
        unparcel(parcelData);
    }

    public static final Creator<Model> CREATOR = new
            Creator<Model>()
            {
                public Model createFromParcel(Parcel parcel)
                {
                    return new Model(parcel);
                }

                public Model[] newArray(int size)
                {
                    return new Model[size];
                }
            };

    @Override
    public void writeToParcel(Parcel parcelData, int flags)
    {
        parcel(parcelData, flags);
    }

    public static String newId()
    {
        return UUID.randomUUID().toString();
    }

    private static Enum<?> findEnumValue(Class<?> enumType, String value)
    {
        for (Enum<?> e : ((Class<? extends Enum<?>>) enumType).getEnumConstants())
        {
            if (e.name().equalsIgnoreCase(value))
                return e;
        }

        return null;
    }

    /**
     * Takes the passed <code>String</code> as JSON and parses it in to the model.
     *
     * @param jsonText - JSON data to parse.
     * @throws JsonParseException
     */
    public void deserialize(String jsonText) throws JsonParseException
    {
        JsonElement rootElement = JsonParser.parseString(jsonText);
        deserialize(rootElement);
    }

    /**
     * Takes the passed <code>JsonElement</code> and parses it in to the model.
     *
     * @param rootElement - The root element to begin parsing.
     * @throws JsonParseException
     */
    public void deserialize(JsonElement rootElement) throws JsonParseException
    {
        deserialize(rootElement, null);
    }

    /**
     * Takes the passed <code>JsonElement</code> and parses it in to the model.
     *
     * @param rootElement - The root element to begin parsing.
     * @param parent      - The parent model of this model.
     * @throws JsonParseException
     */
    public void deserialize(JsonElement rootElement, Model parent) throws JsonParseException
    {
        JsonObject jsonObject = rootElement.getAsJsonObject();

        List<Field> fields = ModelFieldCache.getInstance().getFields(((Object) this).getClass());

        for (Field field : fields)
        {
            Persistent persistent = null;
            try
            {
                persistent = field.getAnnotation(Persistent.class);
            }
            catch (Exception perr)
            {
                perr.printStackTrace();
            }

            String name = field.getName();
            JsonObject subObject = jsonObject;
            JsonElement elem = null;

            if (null != persistent)
            {
                if (!TextUtils.isEmpty(persistent.jsonMap()))
                {
                    String[] mappings = persistent.jsonMap().split("!");
                    for (String map : mappings)
                    {
                        if (!TextUtils.isEmpty(map))
                        {
                            name = map;
                            if (subObject.has(name))
                            {
                                elem = subObject.get(name);
                                if (elem.isJsonObject())
                                {
                                    subObject = elem.getAsJsonObject();
                                }
                                /*
                                // Ugly hack to handle single item array....
                                else if (elem.isJsonArray())
                                {
                                    JsonArray array = elem.getAsJsonArray();
                                    if (array.size() > 0)
                                    {
                                        JsonElement element = array.get(0);
                                        if (element.isJsonObject())
                                        {
                                            subObject = element.getAsJsonObject();
                                        }
                                    }
                                }
                                */
                            }
                        }
                    }
                }
            }

            if (subObject.has(name) || (null != elem && null != persistent && persistent.fromParentValue()))
            {
                if (subObject.has(name))
                {
                    elem = subObject.get(name);
                }

                if (!elem.isJsonNull())
                {
                    Class<?> field_type = field.getType();

                    if (field_type.equals(String.class))
                    {
                        String value = elem.getAsString();
                        Reflection.setFieldValue(this, field, value);
                        if (persistent.idMap())
                        {
                            id += value;
                        }
                    }
                    else if (field_type.equals(Long.class) || field_type.equals(long.class))
                    {
                        long value = elem.getAsLong();
                        Reflection.setFieldValue(this, field, value);
                        if (persistent.idMap())
                        {
                            id += String.valueOf(value);
                        }
                    }
                    else if (field_type.equals(Integer.class) || field_type.equals(int.class))
                    {
                        int value = elem.getAsInt();
                        Reflection.setFieldValue(this, field, (Integer) value);
                        if (persistent.idMap())
                        {
                            id += String.valueOf(value);
                        }
                    }
                    else if (field_type.equals(Double.class) || field_type.equals(double.class))
                    {
                        Reflection.setFieldValue(this, field, (Double) elem.getAsDouble());
                    }
                    else if (field_type.equals(Float.class) || field_type.equals(float.class))
                    {
                        Reflection.setFieldValue(this, field, (Float) elem.getAsFloat());
                    }
                    else if (field_type.equals(Boolean.class) || field_type.equals(boolean.class))
                    {
                        Reflection.setFieldValue(this, field, (Boolean) elem.getAsBoolean());
                    }
                    else if (ModelBasicType.class.isAssignableFrom(field_type))
                    {
                        try
                        {
                            ModelBasicType o = (ModelBasicType) field_type.newInstance();
                            o.fromJsonElement(elem);
                            Reflection.setFieldValue(this, field, o);
                        }
                        catch (Exception e)
                        {
                            e.printStackTrace();
                        }
                    }
                    else if (Enum.class.isAssignableFrom(field_type))
                    {
                        Reflection.setFieldValue(this, field, findEnumValue(field_type, elem.getAsString()));
                    }
                    else if (field_type.equals(byte[].class))
                    {
                        //TODO: do we really want to decode byte arrays as base 64??
                        //TODO: we will need to check the base64 format.
                        Reflection.setFieldValue(this, field, Base64.decode(elem.getAsString(), Base64.DEFAULT));
                    }
                    else if (field_type.equals(ArrayList.class))
                    {
                        ParameterizedType myType = ((ParameterizedType) field.getGenericType());
                        Class<?> typeArg = getTypeClass(myType.getActualTypeArguments()[0]);
                        if (Model.class.isAssignableFrom(typeArg))
                        {
                            ArrayList list = new ArrayList();
                            Reflection.setFieldValue(this, name, list);

                            JsonArray jsonList;

                            if (persistent.fromParentValue())
                            {
                                jsonList = elem.getAsJsonArray();
                            }
                            else
                            {
                                if (persistent.escaped())
                                {
                                    JsonParser parser = new JsonParser();
                                    JsonElement e = parser.parse(elem.getAsString().replaceAll("\\\\", ""));
                                    jsonList = e.getAsJsonArray();
                                }
                                else
                                {
                                    jsonList = subObject.getAsJsonArray(name);
                                }
                            }

                            for (int i = 0; i < jsonList.size(); i++)
                            {
                                final JsonElement element = jsonList.get(i);
                                try
                                {
                                    Model o = (Model) typeArg.newInstance();
                                    o.deserialize(element, this);
                                    list.add(o);
                                }
                                catch (Exception e)
                                {
                                    e.printStackTrace();
                                }
                            }
                        }
                        // Support for String arrays...
                        else if (String.class.isAssignableFrom(typeArg))
                        {
                            ArrayList list = new ArrayList();
                            Reflection.setFieldValue(this, name, list);
                            JsonArray jsonList = subObject.getAsJsonArray(name);
                            for (int i = 0; i < jsonList.size(); i++)
                            {
                                final JsonElement element = jsonList.get(i);
                                try
                                {
                                    String o = element.getAsString();
                                    list.add(o);
                                }
                                catch (Exception e)
                                {
                                    e.printStackTrace();
                                }
                            }
                        }
                    }
                    else if (Model.class.isAssignableFrom(field_type))
                    {
                        JsonElement element;

                        if (persistent.fromParentValue())
                        {
                            element = elem;
                        }
                        else
                        {
                            element = subObject.get(name);
                        }

                        try
                        {
                            Model o = (Model) field_type.newInstance();
                            if (persistent.escaped())
                            {
                                JsonParser parser = new JsonParser();
                                JsonElement e = parser.parse(element.getAsString().replaceAll("\\\\", ""));
                                o.deserialize(e, this);
                            }
                            else
                            {
                                o.deserialize(element, this);
                            }
                            Reflection.setFieldValue(this, name, o);
                        }
                        catch (Exception e)
                        {
                            e.printStackTrace();
                        }
                    }
                    else
                    {
                        throw new IllegalArgumentException("Type is not supported: " + field_type.toString());
                    }
                }
            }
        }

        afterDeserialize();
    }

    /**
     * Encodes the model as JSON data.
     *
     * @param exclude - An optional list of items to exclude from the serialization.
     * @return The resulting JSON data as a <code>String</code>.
     */
    public String serialize(@Nullable String... exclude)
    {
        JsonObject object = new JsonObject();
        serialize(object, exclude);
        return object.toString();
    }

    /**
     * Encodes the model as JSON data.
     *
     * @param exclude - An optional list of items to exclude from the serialization.
     * @return The resulting JSON data as a <code>JSONObject</code>.
     */
    public JSONObject serializeToJson(@Nullable String... exclude)
    {
        JSONObject object = new JSONObject();
        try
        {
            serialize(object, exclude);
        }
        catch (JSONException e)
        {
            e.printStackTrace();
        }
        return object;
    }

    private boolean isNotExcluded(String name, @Nullable String... exclude)
    {
        if (null == exclude)
            return true;

        for (String excluded : exclude)
        {
            if (name.contentEquals(excluded))
                return false;
        }

        return true;
    }

    /**
     * Encodes the model as JSON data.
     *
     * @param object  - The destination for the resulting JSON data as a <code>JSONObject</code>.
     * @param exclude - An optional list of items to exclude from the serialization.
     */
    public void serialize(JSONObject object, @Nullable String... exclude) throws JSONException
    {
        List<Field> fields = ModelFieldCache.getInstance().getFields(((Object) this).getClass());

        for (Field field : fields)
        {
            String name = field.getName();

            if (isNotExcluded(name, exclude))
            {
                Persistent persistent = field.getAnnotation(Persistent.class);

                if (
                        (null != persistent) &&
                                (!persistent.pk()) &&
                                (!persistent.joinedField()) &&
                                (!persistent.fromParent()) &&
                                (persistent.serialize()) &&
                                (persistent.inDb()))
                {
                    Object value = Reflection.getFieldValue(this, field);
                    Class<?> field_type = field.getType();
                    if (null != value)
                    {
                        if (!TextUtils.isEmpty(persistent.jsonMap()))
                        {
                            //TODO: handle advanced mapping... just use as name for now.
                            name = persistent.jsonMap();
                        }

                        if (field_type.equals(String.class))
                        {
                            if (persistent.serializeIfEmpty() || !TextUtils.isEmpty((String) value))
                            {
                                object.put(name, (String) value);
                            }
                        }
                        else if (field_type.equals(Long.class) || field_type.equals(long.class))
                        {
                            object.put(name, (Long) value);
                        }
                        else if (field_type.equals(Integer.class) || field_type.equals(int.class))
                        {
                            object.put(name, (Integer) value);
                        }
                        else if (field_type.equals(Double.class) || field_type.equals(double.class))
                        {
                            object.put(name, (Double) value);
                        }
                        else if (field_type.equals(Float.class) || field_type.equals(float.class))
                        {
                            object.put(name, (Float) value);
                        }
                        else if (field_type.equals(Boolean.class) || field_type.equals(boolean.class))
                        {
                            object.put(name, (Integer) ((Boolean) value ? 1 : 0));
                        }
                        else if (ModelBasicType.class.isAssignableFrom(field_type))
                        {
                            ((ModelBasicType) value).toJSONObject(object, name);
                        }
                        else if (field_type.isEnum())
                        {
                            object.put(name, getEnumValue(field, value));
                        }
                        else if (field_type.equals(byte[].class))
                        {
                            //TODO: do we really want to encode byte arrays as base 64??
                            //TODO: we will need to check the base64 format.
                            object.put(name, Base64.encodeToString((byte[]) value, Base64.DEFAULT));
                        }
                        else if (field_type.equals(ArrayList.class))
                        {
                            ParameterizedType myType = ((ParameterizedType) field.getGenericType());
                            Class<?> typeArg = getTypeClass(myType.getActualTypeArguments()[0]);
                            if (Model.class.isAssignableFrom(typeArg))
                            {
                                JSONArray modelArray = new JSONArray();

                                for (Object o : (ArrayList) value)
                                {
                                    if (null != o)
                                    {
                                        Model m = (Model) o;
                                        if (!persistent.asReference())
                                        {
                                            JSONObject modelObject = new JSONObject();
                                            m.serialize(modelObject, exclude);
                                            modelArray.put(modelObject);
                                        }
                                        else
                                        {
                                            //TODO: check that we always want to use "id".
                                            //TODO: otherwise we'll need to add to persistent to handle.
                                            JSONObject modelObject = new JSONObject();
                                            modelObject.put("id", m.getId());
                                            modelArray.put(modelObject);
                                        }
                                    }
                                }

                                object.put(name, modelArray);
                            }
                            else if (field_type.equals(HashMap.class))
                            {
                                boolean flatten = persistent.flatten();

                                JSONArray modelArray = new JSONArray();

                                HashMap hm = (HashMap) value;
                                for (Object o : hm.keySet())
                                {
                                    if (null != o)
                                    {
                                        Object v = hm.get(o);
                                        if (null != v)
                                        {
                                            JSONObject hashObject = new JSONObject();
                                            hashObject.put((String) o, v);

                                            if (flatten)
                                            {
                                                object.put(name, hashObject);
                                                break;
                                            }
                                            else
                                            {
                                                modelArray.put(hashObject);
                                            }
                                        }
                                    }
                                }
                                if (!flatten)
                                {
                                    object.put(name, modelArray);
                                }
                            }
                            else if (String.class.isAssignableFrom(typeArg))
                            {
                                JSONArray modelArray = new JSONArray();

                                for (Object o : (ArrayList) value)
                                {
                                    if (null != o)
                                    {
                                        String s = (String) o;
                                        modelArray.put(s);
                                    }
                                }
                                object.put(name, modelArray);
                            }
                        }
                        else if (Model.class.isAssignableFrom(field_type))
                        {
                            Model m = (Model) value;
                            if (!persistent.asReference())
                            {
                                JSONObject modelObject = new JSONObject();
                                m.serialize(modelObject, exclude);
                                if (persistent.escaped())
                                {
                                    object.put(name, modelObject.toString().replaceAll("\"", "\\\""));
                                }
                                else
                                {
                                    object.put(name, modelObject);
                                }
                            }
                            else
                            {
                                object.put(name, m.getId());
                            }
                        }
                        else
                        {
                            throw new IllegalArgumentException("Type is not supported: " + field_type.toString());
                        }
                    }
                }
            }
        }
    }

    /**
     * Encodes the model as JSON data.
     *
     * @param object  - The destination for the resulting JSON data as a <code>JsonObject</code>.
     * @param exclude - An optional list of items to exclude from the serialization.
     */
    public void serialize(JsonObject object, @Nullable String... exclude)
    {
        List<Field> fields = ModelFieldCache.getInstance().getFields(((Object) this).getClass());

        for (Field field : fields)
        {
            String name = field.getName();

            if (isNotExcluded(name, exclude))
            {
                Persistent persistent = field.getAnnotation(Persistent.class);

                if (
                        (null != persistent) &&
                                (!persistent.pk()) &&
                                (!persistent.joinedField()) &&
                                (!persistent.fromParent()) &&
                                (persistent.serialize()) &&
                                (persistent.inDb()))
                {
                    Object value = Reflection.getFieldValue(this, field);
                    Class<?> field_type = field.getType();
                    if (null != value)
                    {
                        if (!TextUtils.isEmpty(persistent.jsonMap()))
                        {
                            //TODO: handle advanced mapping... just use as name for now.
                            name = persistent.jsonMap();
                        }

                        if (field_type.equals(String.class))
                        {
                            if (persistent.serializeIfEmpty() || !TextUtils.isEmpty((String) value))
                            {
                                object.addProperty(name, (String) value);
                            }
                        }
                        else if (field_type.equals(Long.class) || field_type.equals(long.class))
                        {
                            object.addProperty(name, (Long) value);
                        }
                        else if (field_type.equals(Integer.class) || field_type.equals(int.class))
                        {
                            object.addProperty(name, (Integer) value);
                        }
                        else if (field_type.equals(Double.class) || field_type.equals(double.class))
                        {
                            object.addProperty(name, (Double) value);
                        }
                        else if (field_type.equals(Float.class) || field_type.equals(float.class))
                        {
                            object.addProperty(name, (Float) value);
                        }
                        else if (field_type.equals(Boolean.class) || field_type.equals(boolean.class))
                        {
                            object.addProperty(name, (Integer) ((Boolean) value ? 1 : 0));
                        }
                        else if (ModelBasicType.class.isAssignableFrom(field_type))
                        {
                            ((ModelBasicType) value).toJsonObject(object, name);
                        }
                        else if (field_type.isEnum())
                        {
                            object.addProperty(name, getEnumValue(field, value));
                        }
                        else if (field_type.equals(byte[].class))
                        {
                            //TODO: do we really want to encode byte arrays as base 64??
                            //TODO: we will need to check the base64 format.
                            object.addProperty(name, Base64.encodeToString((byte[]) value, Base64.DEFAULT));
                        }
                        else if (field_type.equals(ArrayList.class))
                        {
                            ParameterizedType myType = ((ParameterizedType) field.getGenericType());
                            Class<?> typeArg = getTypeClass(myType.getActualTypeArguments()[0]);
                            if (Model.class.isAssignableFrom(typeArg))
                            {
                                JsonArray modelArray = new JsonArray();

                                for (Object o : (ArrayList) value)
                                {
                                    if (null != o)
                                    {
                                        Model m = (Model) o;
                                        JsonObject modelObject = new JsonObject();
                                        m.serialize(modelObject, exclude);
                                        modelArray.add(modelObject);
                                    }
                                }

                                if (persistent.escaped())
                                {
                                    object.addProperty(name, modelArray.toString().replaceAll("\"", "\\\""));
                                }
                                else
                                {
                                    object.add(name, modelArray);
                                }
                            }
                            else if (String.class.isAssignableFrom(typeArg))
                            {
                                JsonArray modelArray = new JsonArray();

                                for (Object o : (ArrayList) value)
                                {
                                    if (null != o)
                                    {
                                        String s = (String) o;
                                        modelArray.add(s);
                                    }
                                }
                                object.add(name, modelArray);
                            }
                        }
                        else if (field_type.equals(HashMap.class))
                        {
                            boolean flatten = persistent.flatten();

                            JsonArray modelArray = new JsonArray();

                            HashMap hm = (HashMap) value;
                            for (Object o : hm.keySet())
                            {
                                if (null != o)
                                {
                                    Object v = hm.get(o);
                                    if (null != v)
                                    {
                                        JsonObject hashObject = new JsonObject();
                                        hashObject.addProperty((String) o, (String) v);

                                        if (flatten)
                                        {
                                            object.add(name, hashObject);
                                            break;
                                        }
                                        else
                                        {
                                            modelArray.add(hashObject);
                                        }
                                    }
                                }
                            }
                            if (!flatten)
                            {
                                object.add(name, modelArray);
                            }
                        }
                        else if (Model.class.isAssignableFrom(field_type))
                        {
                            Model m = (Model) value;
                            if (!persistent.asReference())
                            {
                                JsonObject modelObject = new JsonObject();
                                m.serialize(modelObject, exclude);
                                if (persistent.escaped())
                                {
                                    object.addProperty(name, modelObject.toString().replaceAll("\"", "\\\""));
                                }
                                else
                                {
                                    object.add(name, modelObject);
                                }
                            }
                            else
                            {
                                object.addProperty(name, m.getId());
                            }
                        }
                        else
                        {
                            throw new IllegalArgumentException("Type is not supported: " + field_type.toString());
                        }
                    }
                }
            }
        }
    }

    private String replaceFields(String src)
    {
        Pattern pattern = Pattern.compile("%[^%]+%");
        Matcher matcher = pattern.matcher(src);

        List<Field> fields = ModelFieldCache.getInstance().getFields(((Object) this).getClass());
        StringBuilder result = new StringBuilder(src);
        while (matcher.find())
        {
            String found = matcher.group();
            found = found.substring(1, found.length() - 1);

            for (Field field : fields)
            {
                String name = field.getName();
                if (0 == name.compareToIgnoreCase(found))
                {
                    Object value = Reflection.getFieldValue(this, field);
                    if (null != value)
                    {
                        String valueStr = value.toString();
                        if (!TextUtils.isEmpty(valueStr))
                        {
                            result.replace(matcher.start(), matcher.end(), valueStr);
                        }
                        else
                        {
                            result.delete(0, result.length());
                        }
                    }
                    break;
                }
            }
        }

        return result.toString();
    }

    /**
     * Override to handle any post read operations - e.g. sorting.
     */
    public void afterReadFromCursor()
    {
    }

    /**
     * Override to handle any post deserialize operations - e.g. model init.
     */
    public void afterDeserialize()
    {

    }

    /**
     * Reads the model fields from the supplied <code>Cursor</code>
     *
     * @param cursor - <code>Cursor</code> to read from.
     */
    public void readFromCursor(Cursor cursor)
    {
        readFromCursor(cursor, null, DEFAULT_DEPTH, DEFAULT_DEPTH);
    }

    /**
     * Reads model fields from the supplied <code>Cursor</code>.
     *
     * @param cursor       - <code>Cursor</code> to read from.
     * @param fieldsToRead - array of field names to read from the <code>Cursor</code> or null to
     *                     read all fields.
     */
    public void readFromCursor(Cursor cursor, String... fieldsToRead)
    {
        readFromCursor(cursor, null, DEFAULT_DEPTH, DEFAULT_DEPTH, fieldsToRead);
    }

    /**
     * Reads model fields from the supplied <code>Cursor</code>.
     *
     * @param cursor          - <code>Cursor</code> to read from.
     * @param parent          - parent Model of this model.
     * @param childDepth      - depth of child models to read.
     * @param childArrayDepth - depth of child List<Model> models to read.
     * @param fieldsToRead    - array of field names to read from the <code>Cursor</code> or null to
     *                        read all fields.
     */
    public void readFromCursor(Cursor cursor, Model parent, int childDepth, int childArrayDepth, String... fieldsToRead)
    {
        childDepth--;
        childArrayDepth--;

        List<Field> fields = ModelFieldCache.getInstance().getFields(((Object) this).getClass());

        for (Field field : fields)
        {
            Persistent persistent = field.getAnnotation(Persistent.class);
            if (null != persistent)
            {
                String name = field.getName();
                boolean bReadField = true;

                if ((null != fieldsToRead) && (fieldsToRead.length > 0))
                {
                    bReadField = false;

                    for (String fieldToRead : fieldsToRead)
                    {
                        if (name.contentEquals(fieldToRead))
                        {
                            bReadField = true;
                            break;
                        }
                    }
                }

                if (bReadField)
                {
                    int index = cursor.getColumnIndex(name);
                    if (index >= 0 && !cursor.isClosed())
                    {
                        Class<?> field_type = field.getType();
                        if (field_type.equals(String.class))
                        {
                            Reflection.setFieldValue(this, field, cursor.getString(index));
                        }
                        else if (field_type.equals(Long.class) || field_type.equals(long.class))
                        {
                            Reflection.setFieldValue(this, field, cursor.getLong(index));
                        }
                        else if (field_type.equals(Integer.class) || field_type.equals(int.class))
                        {
                            Reflection.setFieldValue(this, field, (Integer) cursor.getInt(index));
                        }
                        else if (field_type.equals(Double.class) || field_type.equals(double.class))
                        {
                            Reflection.setFieldValue(this, field, (Double) cursor.getDouble(index));
                        }
                        else if (field_type.equals(Float.class) || field_type.equals(float.class))
                        {
                            Reflection.setFieldValue(this, field, (Float) cursor.getFloat(index));
                        }
                        else if (field_type.equals(Boolean.class) || field_type.equals(boolean.class))
                        {
                            Reflection.setFieldValue(this, field, (Boolean) (cursor.getInt(index) == 1 ? Boolean.TRUE : Boolean.FALSE));
                        }
                        else if (ModelBasicType.class.isAssignableFrom(field_type))
                        {
                            try
                            {
                                ModelBasicType o = (ModelBasicType) field_type.newInstance();
                                o.readFromCursor(cursor, index, this);
                                Reflection.setFieldValue(this, field, o);
                            }
                            catch (Exception e)
                            {
                                e.printStackTrace();
                            }
                        }
                        else if (field_type.isEnum())
                        {
                            Reflection.setFieldEnumValue(this, field, cursor.getString(index));
                        }
                        else if (field_type.equals(byte[].class))
                        {
                            Reflection.setFieldValue(this, field, cursor.getBlob(index));
                        }
                        else if (field_type.equals(ArrayList.class))
                        {
                            ParameterizedType myType = ((ParameterizedType) field.getGenericType());
                            Class<?> typeArg = getTypeClass(myType.getActualTypeArguments()[0]);
                            if ((Model.class.isAssignableFrom(typeArg)) && (childArrayDepth >= 0))
                            {
                                String queryStr = persistent.query();
                                if (TextUtils.isEmpty(queryStr))
                                {
                                    ArrayList list = new ArrayList();
                                    Reflection.setFieldValue(this, field, list);
                                    String indexes = cursor.getString(index);
                                    if (!TextUtils.isEmpty(indexes))
                                    {
                                        String[] tokens = indexes.split(Character.toString((char) 1));
                                        for (String idStr : tokens)
                                        {
                                            if (!TextUtils.isEmpty(idStr))
                                            {
                                                Model m = null;

                                                // try to get from the cache...
                                                m = ORMDbCache.getInstance().getModel(
                                                        (Class<Model>) typeArg,
                                                        this,
                                                        idStr,
                                                        childDepth,
                                                        childArrayDepth);

                                                if (null == m)
                                                {
                                                    // try to get from the database.
                                                    m = ORMTable.getModel(
                                                            (Class<Model>) typeArg,
                                                            this,
                                                            String.format("%s='%s'", getIdFieldName(typeArg), idStr),
                                                            null,
                                                            childDepth,
                                                            childArrayDepth);
                                                }

                                                if (null != m)
                                                {
                                                    list.add(m);
                                                }
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    queryStr = replaceFields(queryStr);
                                    if (!TextUtils.isEmpty(queryStr))
                                    {
                                        ArrayList list = ORMTable.getModelList(
                                                (Class<Model>) typeArg,
                                                this,
                                                queryStr,
                                                null);
                                        Reflection.setFieldValue(this, field, list);
                                    }
                                }
                            }
                            else if (String.class.isAssignableFrom(typeArg))
                            {
                                ArrayList list = new ArrayList();
                                Reflection.setFieldValue(this, field, list);
                                String values = cursor.getString(index);
                                if (!TextUtils.isEmpty(values))
                                {
                                    String[] tokens = values.split(Character.toString((char) 1));
                                    for (String idStr : tokens)
                                    {
                                        if (!TextUtils.isEmpty(idStr))
                                        {
                                            list.add(idStr);
                                        }
                                    }
                                }
                            }
                        }
                        else if (field_type.equals(HashMap.class))
                        {
                            String values = cursor.getString(index);
                            Gson gson = new Gson();
                            HashMap map = (HashMap) gson.fromJson(values, field_type);
                            Reflection.setFieldValue(this, field, map);
                        }
                        else if (Model.class.isAssignableFrom(field_type))
                        {
                            if (persistent.fromParent() && null != parent)
                            {
                                Reflection.setFieldValue(this, name, parent); //TODO:
                            }
                            else if (childDepth >= 0)
                            {
                                String queryStr = persistent.query();
                                if (TextUtils.isEmpty(queryStr))
                                {
                                    String idStr = cursor.getString(index);
                                    if (!TextUtils.isEmpty(idStr))
                                    {
                                        Model m = null;

                                        // try to get from the cache...
                                        m = ORMDbCache.getInstance().getModel(
                                                (Class<Model>) field_type,
                                                this,
                                                idStr,
                                                childDepth,
                                                childArrayDepth);

                                        if (null == m)
                                        {
                                            // Then try to get from the database.
                                            m = ORMTable.getModel(
                                                    (Class<Model>) field_type,
                                                    this,
                                                    String.format("%s='%s'", getIdFieldName(field_type), idStr),
                                                    null,
                                                    childDepth,
                                                    childArrayDepth);
                                        }

                                        if (null != m)
                                        {
                                            Reflection.setFieldValue(this, name, m);
                                        }
                                    }
                                    else
                                    {
                                        queryStr = replaceFields(queryStr);
                                        if (!TextUtils.isEmpty(queryStr))
                                        {
                                            Model m = ORMTable.getModel(
                                                    (Class<Model>) field_type,
                                                    this,
                                                    queryStr,
                                                    null,
                                                    childDepth,
                                                    childArrayDepth);
                                            if (null != m)
                                            {
                                                Reflection.setFieldValue(this, name, m);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else
                        {
                            throw new IllegalArgumentException("Type is not supported: " + field_type.toString());
                        }
                    }
                }
            }
        }

        afterReadFromCursor();
    }

    /**
     * Compares field values with the <code>Cursor</code> values and generates <code>ContentValues</code>
     * for fields that differ.
     *
     * @param cursor - Cursor to compare values.
     * @return <code>ContentValues</code> that differ and need to be updated in the database.
     */
    public ContentValues getContentValues(Cursor cursor)
    {
        ContentValues values = new ContentValues();
        List<Field> fields = ModelFieldCache.getInstance().getFields(((Object) this).getClass());
        boolean bTryUpdate = (null != cursor && cursor.getCount() > 0);

        for (Field field : fields)
        {
            Persistent persistent = field.getAnnotation(Persistent.class);
            if ((null != persistent) && (!persistent.pk()) && (!persistent.joinedField()) && (persistent.inDb()))
            {
                String name = field.getName();
                int index = (bTryUpdate ? cursor.getColumnIndex(name) : -1);
                Object value = Reflection.getFieldValue(this, field);
                Class<?> field_type = field.getType();

                boolean bUpdate = (bTryUpdate && !cursor.isNull(index));

                if (null != value)
                {
                    if (field_type.equals(String.class))
                    {
                        if (!bUpdate)
                            values.put(name, (String) value);
                        else if (!cursor.getString(index).contentEquals((String) value))
                            values.put(name, (String) value);
                    }
                    else if (field_type.equals(Long.class) || field_type.equals(long.class))
                    {
                        if (!bUpdate)
                            values.put(name, (Long) value);
                        else if (0 != Long.valueOf(cursor.getLong(index)).compareTo(Long.valueOf((Long) value)))
                            values.put(name, (Long) value);
                    }
                    else if (field_type.equals(Integer.class) || field_type.equals(int.class))
                    {
                        if (!bUpdate)
                            values.put(name, (Integer) value);
                        else if (cursor.getInt(index) != (Integer) value)
                            values.put(name, (Integer) value);
                    }
                    else if (field_type.equals(Double.class) || field_type.equals(double.class))
                    {
                        if (!bUpdate)
                            values.put(name, (Double) value);
                        else if (0 != Double.valueOf(cursor.getDouble(index)).compareTo((Double) value))
                            values.put(name, (Double) value);
                    }
                    else if (field_type.equals(Float.class) || field_type.equals(float.class))
                    {
                        if (!bUpdate)
                            values.put(name, (Float) value);
                        else if (0 != Float.valueOf(cursor.getFloat(index)).compareTo((Float) value))
                            values.put(name, (Float) value);
                    }
                    else if (field_type.equals(Boolean.class) || field_type.equals(boolean.class))
                    {
                        if (!bUpdate)
                            values.put(name, (Integer) ((Boolean) value ? 1 : 0));
                        else if ((cursor.getInt(index) == 1 ? Boolean.TRUE : Boolean.FALSE) != (Boolean) value)
                            values.put(name, (Integer) ((Boolean) value ? 1 : 0));
                    }
                    else if (ModelBasicType.class.isAssignableFrom(field_type))
                    {
                        //TODO:
                        ((ModelBasicType) value).toContentValue(values, name);
                    }
                    else if (field_type.isEnum())
                    {
                        String e = getEnumValue(field, value);
                        if (!bUpdate)
                            values.put(name, e);
                        else if (!cursor.getString(index).contentEquals(e))
                            values.put(name, e);
                    }
                    else if (field_type.equals(byte[].class))
                    {
                        values.put(name, (byte[]) value);
                    }
                    else if (field_type.equals(ArrayList.class))
                    {
                        // Treat array list of Model objects as a String of comma separated values.
                        ParameterizedType myType = ((ParameterizedType) field.getGenericType());
                        Class<?> typeArg = getTypeClass(myType.getActualTypeArguments()[0]);
                        if (Model.class.isAssignableFrom(typeArg))
                        {
                            if (TextUtils.isEmpty(persistent.query()))
                            {
                                boolean bChanged = false;

                                if (bUpdate)
                                {
                                    HashSet<String> srcids = new HashSet<>();
                                    String indexes = cursor.getString(index);
                                    if (!TextUtils.isEmpty(indexes))
                                    {
                                        String[] tokens = indexes.split(Character.toString((char) 1));
                                        for (String idStr : tokens)
                                        {
                                            if (!TextUtils.isEmpty(idStr))
                                            {
                                                srcids.add(idStr);
                                            }
                                        }
                                    }

                                    HashSet<String> dstids = new HashSet<>();
                                    for (Model m : (ArrayList<Model>) value)
                                    {
                                        dstids.add(m.getId());
                                    }
                                    Iterator<String> it;
                                    int srcSize = srcids.size();
                                    int dstSize = dstids.size();
                                    if (srcSize >= dstSize)
                                    {
                                        it = srcids.iterator();
                                        while (it.hasNext())
                                        {
                                            String id = it.next();
                                            if (!dstids.remove(id))
                                            {
                                                bChanged = true;
                                                break;
                                            }
                                        }
                                    }
                                    else
                                    {
                                        it = dstids.iterator();
                                        while (it.hasNext())
                                        {
                                            String id = it.next();
                                            if (!srcids.remove(id))
                                            {
                                                bChanged = true;
                                                break;
                                            }
                                        }
                                    }
                                }
                                else
                                {
                                    bChanged = true;
                                }

                                if (bChanged)
                                {
                                    for (Object o : (ArrayList) value)
                                    {
                                        if (null != o)
                                        {
                                            Model m = (Model) o;
                                            String val = (String) values.get(name);
                                            if (TextUtils.isEmpty(val))
                                            {
                                                val = Character.toString((char) 1) + m.getId() + Character.toString((char) 1);
                                            }
                                            else
                                            {
                                                val += m.getId() + Character.toString((char) 1);
                                            }
                                            values.put(name, val);
                                        }
                                    }
                                }
                            }
                        }
                        else if (String.class.isAssignableFrom(typeArg))
                        {
                            boolean bChanged = true;
                            if (bChanged)
                            {
                                for (Object o : (ArrayList) value)
                                {
                                    if (null != o)
                                    {
                                        String m = (String) o;
                                        String val = (String) values.get(name);
                                        if (TextUtils.isEmpty(val))
                                        {
                                            val = Character.toString((char) 1) + m + Character.toString((char) 1);
                                        }
                                        else
                                        {
                                            val += m + Character.toString((char) 1);
                                        }
                                        values.put(name, val);
                                    }
                                }
                            }
                        }
                    }
                    else if (field_type.equals(HashMap.class))
                    {
                        Gson gson = new Gson();
                        String map = gson.toJson(value);

                        if (!bUpdate)
                            values.put(name, map);
                        else if (!cursor.getString(index).contentEquals(map))
                            values.put(name, map);
                    }
                    else if (Model.class.isAssignableFrom(field_type))
                    {
                        Model m = (Model) value;
                        if (!bUpdate)
                            values.put(name, m.getId());
                        else if (!cursor.getString(index).contentEquals(m.id))
                            values.put(name, m.getId());
                    }
                    else
                    {
                        throw new IllegalArgumentException("Type is not supported: " + field_type.toString());
                    }
                }
                else
                {
                    values.putNull(name);
                }
            }
        }
        return values;
    }

    /**
     * Compares field values with the <code>Cursor</code> values and generates <code>ContentValues</code>
     * for fields in 'fieldsToGet' list that differ.
     *
     * @param cursor - Cursor to compare values.
     * @return <code>ContentValues</code> that differ and need to be updated in the database.
     */
    public ContentValues getContentValues(Cursor cursor, String... fieldsToGet)
    {
        ContentValues values = new ContentValues();
        List<Field> fields = ModelFieldCache.getInstance().getFields(((Object) this).getClass());
        boolean bTryUpdate = (null != cursor && cursor.getCount() > 0);

        for (Field field : fields)
        {
            if (ArrayUtils.contains(fieldsToGet, field.getName()))
            {
                Persistent persistent = field.getAnnotation(Persistent.class);
                if ((null != persistent) && (!persistent.pk()) && (!persistent.joinedField()) && (persistent.inDb()))
                {
                    String name = field.getName();
                    int index = (bTryUpdate ? cursor.getColumnIndex(name) : -1);
                    Object value = Reflection.getFieldValue(this, field);
                    Class<?> field_type = field.getType();

                    boolean bUpdate = (bTryUpdate && !cursor.isNull(index));

                    if (null != value)
                    {
                        if (field_type.equals(String.class))
                        {
                            if (!bUpdate)
                                values.put(name, (String) value);
                            else if (!cursor.getString(index).contentEquals((String) value))
                                values.put(name, (String) value);
                        }
                        else if (field_type.equals(Long.class) || field_type.equals(long.class))
                        {
                            if (!bUpdate)
                                values.put(name, (Long) value);
                            else if (0 != Long.valueOf(cursor.getLong(index)).compareTo(Long.valueOf((Long) value)))
                                values.put(name, (Long) value);
                        }
                        else if (field_type.equals(Integer.class) || field_type.equals(int.class))
                        {
                            if (!bUpdate)
                                values.put(name, (Integer) value);
                            else if (cursor.getInt(index) != (Integer) value)
                                values.put(name, (Integer) value);
                        }
                        else if (field_type.equals(Double.class) || field_type.equals(double.class))
                        {
                            if (!bUpdate)
                                values.put(name, (Double) value);
                            else if (0 != Double.valueOf(cursor.getDouble(index)).compareTo((Double) value))
                                values.put(name, (Double) value);
                        }
                        else if (field_type.equals(Float.class) || field_type.equals(float.class))
                        {
                            if (!bUpdate)
                                values.put(name, (Float) value);
                            else if (0 != Float.valueOf(cursor.getFloat(index)).compareTo((Float) value))
                                values.put(name, (Float) value);
                        }
                        else if (field_type.equals(Boolean.class) || field_type.equals(boolean.class))
                        {
                            if (!bUpdate)
                                values.put(name, (Integer) ((Boolean) value ? 1 : 0));
                            else if ((cursor.getInt(index) == 1 ? Boolean.TRUE : Boolean.FALSE) != (Boolean) value)
                                values.put(name, (Integer) ((Boolean) value ? 1 : 0));
                        }
                        else if (ModelBasicType.class.isAssignableFrom(field_type))
                        {
                            //TODO:
                            ((ModelBasicType) value).toContentValue(values, name);
                        }
                        else if (field_type.isEnum())
                        {
                            String e = getEnumValue(field, value);
                            if (!bUpdate)
                                values.put(name, e);
                            else if (!cursor.getString(index).contentEquals(e))
                                values.put(name, e);
                        }
                        else if (field_type.equals(byte[].class))
                        {
                            values.put(name, (byte[]) value);
                        }
                        else if (field_type.equals(ArrayList.class))
                        {
                            // Treat array list of Model objects as a String of comma separated values.
                            ParameterizedType myType = ((ParameterizedType) field.getGenericType());
                            Class<?> typeArg = getTypeClass(myType.getActualTypeArguments()[0]);
                            if (Model.class.isAssignableFrom(typeArg))
                            {
                                if (TextUtils.isEmpty(persistent.query()))
                                {
                                    boolean bChanged = false;

                                    if (bUpdate)
                                    {
                                        HashSet<String> srcids = new HashSet<>();
                                        String indexes = cursor.getString(index);
                                        if (!TextUtils.isEmpty(indexes))
                                        {
                                            String[] tokens = indexes.split(Character.toString((char) 1));
                                            for (String idStr : tokens)
                                            {
                                                if (!TextUtils.isEmpty(idStr))
                                                {
                                                    srcids.add(idStr);
                                                }
                                            }
                                        }

                                        HashSet<String> dstids = new HashSet<>();
                                        for (Model m : (ArrayList<Model>) value)
                                        {
                                            dstids.add(m.getId());
                                        }
                                        Iterator<String> it;
                                        int srcSize = srcids.size();
                                        int dstSize = dstids.size();
                                        if (srcSize >= dstSize)
                                        {
                                            it = srcids.iterator();
                                            while (it.hasNext())
                                            {
                                                String id = it.next();
                                                if (!dstids.remove(id))
                                                {
                                                    bChanged = true;
                                                    break;
                                                }
                                            }
                                        }
                                        else
                                        {
                                            it = dstids.iterator();
                                            while (it.hasNext())
                                            {
                                                String id = it.next();
                                                if (!srcids.remove(id))
                                                {
                                                    bChanged = true;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                    else
                                    {
                                        bChanged = true;
                                    }

                                    if (bChanged)
                                    {
                                        for (Object o : (ArrayList) value)
                                        {
                                            if (null != o)
                                            {
                                                Model m = (Model) o;
                                                String val = (String) values.get(name);
                                                if (TextUtils.isEmpty(val))
                                                {
                                                    val = Character.toString((char) 1) + m.getId() + Character.toString((char) 1);
                                                }
                                                else
                                                {
                                                    val += m.getId() + Character.toString((char) 1);
                                                }
                                                values.put(name, val);
                                            }
                                        }
                                    }
                                }
                            }
                            else if (String.class.isAssignableFrom(typeArg))
                            {
                                boolean bChanged = true;
                                if (bChanged)
                                {
                                    for (Object o : (ArrayList) value)
                                    {
                                        if (null != o)
                                        {
                                            String m = (String) o;
                                            String val = (String) values.get(name);
                                            if (TextUtils.isEmpty(val))
                                            {
                                                val = Character.toString((char) 1) + m + Character.toString((char) 1);
                                            }
                                            else
                                            {
                                                val += m + Character.toString((char) 1);
                                            }
                                            values.put(name, val);
                                        }
                                    }
                                }
                            }
                        }
                        else if (field_type.equals(HashMap.class))
                        {
                            Gson gson = new Gson();
                            String map = gson.toJson(value);

                            if (!bUpdate)
                                values.put(name, map);
                            else if (!cursor.getString(index).contentEquals(map))
                                values.put(name, map);
                        }
                        else if (Model.class.isAssignableFrom(field_type))
                        {
                            Model m = (Model) value;
                            if (!bUpdate)
                                values.put(name, m.getId());
                            else if (!cursor.getString(index).contentEquals(m.id))
                                values.put(name, m.getId());
                        }
                        else
                        {
                            throw new IllegalArgumentException("Type is not supported: " + field_type.toString());
                        }
                    }
                    else
                    {
                        values.putNull(name);
                    }
                }
            }
        }
        return values;
    }

    /**
     * Returns the database table schema for the model.
     *
     * @param clazz - The Model Class type.
     * @return - Model schema as a String.
     */
    public static String getTable(Class clazz)
    {
        StringBuilder result = new StringBuilder();

        boolean bFirst = true;

        // This can't be cached because it's called from ORMTable.
        List<Field> fields = Reflection.getAllDeclaredNonStaticFieldsSorted(clazz);
        for (Field field : fields)
        {
            Persistent persistent = field.getAnnotation(Persistent.class);
            if ((null != persistent) && (!persistent.joinedField()) && (persistent.inDb()))
            {
                String name = field.getName();
                Class<?> field_type = field.getType();
                if (field_type.equals(String.class))
                {
                    if (!bFirst)
                        result.append(",");
                    result.append(String.format("%s BLOB %s", name, persistent.appDb()));
                    bFirst = false;
                }
                else if (field_type.equals(Long.class) || field_type.equals(long.class))
                {
                    if (!bFirst)
                        result.append(",");
                    result.append(String.format("%s INTEGER %s", name, persistent.appDb()));
                    bFirst = false;
                }
                else if (field_type.equals(Integer.class) || field_type.equals(int.class))
                {
                    if (!bFirst)
                        result.append(",");
                    result.append(String.format("%s INTEGER %s", name, persistent.appDb()));
                    bFirst = false;
                }
                else if (field_type.equals(Double.class) || field_type.equals(double.class))
                {
                    if (!bFirst)
                        result.append(",");
                    result.append(String.format("%s REAL %s", name, persistent.appDb()));
                    bFirst = false;
                }
                else if (field_type.equals(Float.class) || field_type.equals(float.class))
                {
                    if (!bFirst)
                        result.append(",");
                    result.append(String.format("%s REAL %s", name, persistent.appDb()));
                    bFirst = false;
                }
                else if (field_type.equals(Boolean.class) || field_type.equals(boolean.class))
                {
                    if (!bFirst)
                        result.append(",");
                    result.append(String.format("%s INTEGER %s", name, persistent.appDb()));
                    bFirst = false;
                }
                else if (ModelBasicType.class.isAssignableFrom(field_type))
                {
                    try
                    {
                        ModelBasicType o = (ModelBasicType) field_type.newInstance();
                        if (!bFirst)
                            result.append(",");
                        result.append(o.getTable(persistent, name));
                    }
                    catch (Exception e)
                    {
                        e.printStackTrace();
                    }
                }
                else if (field_type.isEnum())
                {
                    if (!bFirst)
                        result.append(",");
                    result.append(String.format("%s TEXT %s", name, persistent.appDb()));
                    bFirst = false;
                }
                else if (field_type.equals(byte[].class))
                {
                    if (!bFirst)
                        result.append(",");
                    result.append(String.format("%s BLOB %s", name, persistent.appDb()));
                    bFirst = false;
                }
                else if (field_type.equals(ArrayList.class))
                {
                    ParameterizedType myType = ((ParameterizedType) field.getGenericType());
                    Class<?> typeArg = getTypeClass(myType.getActualTypeArguments()[0]);
                    if (Model.class.isAssignableFrom(typeArg))
                    {
                        if (!bFirst)
                            result.append(",");
                        result.append(String.format("%s TEXT %s", name, persistent.appDb()));
                        bFirst = false;
                    }
                    else if (String.class.isAssignableFrom(typeArg))
                    {
                        if (!bFirst)
                            result.append(",");
                        result.append(String.format("%s TEXT %s", name, persistent.appDb()));
                        bFirst = false;
                    }
                }
                else if (field_type.equals(HashMap.class))
                {
                    if (!bFirst)
                        result.append(",");
                    result.append(String.format("%s TEXT %s", name, persistent.appDb()));
                    bFirst = false;
                }
                else if (Model.class.isAssignableFrom(field_type))
                {
                    if (!bFirst)
                        result.append(",");
                    result.append(String.format("%s BLOB %s", name, persistent.appDb()));
                    bFirst = false;
                }
                else
                {
                    throw new IllegalArgumentException("Type is not supported: " + field_type.toString());
                }
            }
        }
        return result.toString();
    }

    /**
     * Gets the column names for the Model as a comma separated list.
     *
     * @param clazz - The Model class type.
     * @return - column names.
     */
    public static String getColumns(Class clazz)
    {
        return getColumns(clazz, false);
    }

    /**
     * Gets the column names for the Model as a comma separated list.
     * This variant supports the option to prefix the column names with the table name.
     *
     * @param clazz      - The Model class type.
     * @param bFullNames - If true the table name will be prefixed to the values.
     * @return - column names.
     */
    public static String getColumns(Class<? extends Model> clazz, boolean bFullNames)
    {
        StringBuilder result = new StringBuilder();
        String table = Orm.getModelName(clazz) + ".";
        boolean bFirst = true;

        List<Field> fields = ModelFieldCache.getInstance().getFields(clazz);
        for (Field field : fields)
        {
            Persistent persistent = field.getAnnotation(Persistent.class);
            if ((null != persistent) && (!persistent.joinedField()) && (persistent.inDb()))
            {
                String name = field.getName();

                Class<?> field_type = field.getType();
                if (field_type.equals(String.class))
                {
                    if (!bFirst)
                        result.append(",");
                    if (bFullNames)
                    {
                        result.append(table);
                    }
                    result.append(name);
                    bFirst = false;
                }
                else if (field_type.equals(Long.class) || field_type.equals(long.class))
                {
                    if (!bFirst)
                        result.append(",");
                    if (bFullNames)
                    {
                        result.append(table);
                    }
                    result.append(name);
                    bFirst = false;
                }
                else if (field_type.equals(Integer.class) || field_type.equals(int.class))
                {
                    if (!bFirst)
                        result.append(",");
                    if (bFullNames)
                    {
                        result.append(table);
                    }
                    result.append(name);
                    bFirst = false;
                }
                else if (field_type.equals(Double.class) || field_type.equals(double.class))
                {
                    if (!bFirst)
                        result.append(",");
                    if (bFullNames)
                    {
                        result.append(table);
                    }
                    result.append(name);
                    bFirst = false;
                }
                else if (field_type.equals(Float.class) || field_type.equals(float.class))
                {
                    if (!bFirst)
                        result.append(",");
                    if (bFullNames)
                    {
                        result.append(table);
                    }
                    result.append(name);
                    bFirst = false;
                }
                else if (field_type.equals(Boolean.class) || field_type.equals(boolean.class))
                {
                    if (!bFirst)
                        result.append(",");
                    if (bFullNames)
                    {
                        result.append(table);
                    }
                    result.append(name);
                    bFirst = false;
                }
                else if (ModelBasicType.class.isAssignableFrom(field_type))
                {
                    if (!bFirst)
                        result.append(",");
                    if (bFullNames)
                    {
                        result.append(table);
                    }
                    result.append(name);
                    bFirst = false;
                }
                else if (field_type.isEnum())
                {
                    if (!bFirst)
                        result.append(",");
                    if (bFullNames)
                    {
                        result.append(table);
                    }
                    result.append(name);
                    bFirst = false;
                }
                else if (field_type.equals(byte[].class))
                {
                    if (!bFirst)
                        result.append(",");
                    if (bFullNames)
                    {
                        result.append(table);
                    }
                    result.append(name);
                    bFirst = false;
                }
                else if (field_type.equals(ArrayList.class))
                {
                    ParameterizedType myType = ((ParameterizedType) field.getGenericType());
                    Class<?> typeArg = getTypeClass(myType.getActualTypeArguments()[0]);
                    if (Model.class.isAssignableFrom(typeArg))
                    {
                        if (!bFirst)
                            result.append(",");
                        bFirst = false;
                        if (bFullNames)
                        {
                            result.append(table);
                        }
                        result.append(name);
                    }
                    else if (String.class.isAssignableFrom(typeArg))
                    {
                        if (!bFirst)
                            result.append(",");
                        bFirst = false;
                        if (bFullNames)
                        {
                            result.append(table);
                        }
                        result.append(name);
                    }
                }
                else if (field_type.equals(HashMap.class))
                {
                    if (!bFirst)
                        result.append(",");
                    bFirst = false;
                    if (bFullNames)
                    {
                        result.append(table);
                    }
                    result.append(name);
                }
                else if (Model.class.isAssignableFrom(field_type))
                {
                    if (!bFirst)
                        result.append(",");
                    bFirst = false;
                    if (bFullNames)
                    {
                        result.append(table);
                    }
                    result.append(name);
                }
                else
                {
                    throw new IllegalArgumentException("Type is not supported: " + field_type.toString());
                }
            }
        }

        return result.toString();
    }

    /**
     * Gets the column types (int, float, String etc) as a comma separated list.
     *
     * @param clazz - The Model class.
     * @return - The resulting string.
     */
    public static String getColumnTypes(Class clazz)
    {
        StringBuilder result = new StringBuilder();
        boolean bFirst = true;

        List<Field> fields = ModelFieldCache.getInstance().getFields(clazz);
        for (Field field : fields)
        {
            Persistent persistent = field.getAnnotation(Persistent.class);
            if ((null != persistent) && (!persistent.joinedField()) && (persistent.inDb()))
            {
                Class<?> field_type = field.getType();

                if (field_type.equals(String.class))
                {
                    if (!bFirst)
                        result.append(",");
                    result.append("string");
                    bFirst = false;
                }
                else if (field_type.equals(Long.class) || field_type.equals(long.class))
                {
                    if (!bFirst)
                        result.append(",");
                    result.append("long");
                    bFirst = false;
                }
                else if (field_type.equals(Integer.class) || field_type.equals(int.class))
                {
                    if (!bFirst)
                        result.append(",");
                    result.append("int");
                    bFirst = false;
                }
                else if (field_type.equals(Double.class) || field_type.equals(double.class))
                {
                    if (!bFirst)
                        result.append(",");
                    result.append("double");
                    bFirst = false;
                }
                else if (field_type.equals(Float.class) || field_type.equals(float.class))
                {
                    if (!bFirst)
                        result.append(",");
                    result.append("float");
                    bFirst = false;
                }
                else if (field_type.equals(Boolean.class) || field_type.equals(boolean.class))
                {
                    if (!bFirst)
                        result.append(",");
                    result.append("bool");
                    bFirst = false;
                }
                else if (ModelBasicType.class.isAssignableFrom(field_type))
                {
                    try
                    {
                        ModelBasicType o = (ModelBasicType) field_type.newInstance();
                        if (!bFirst)
                            result.append(",");
                        result.append(o.getColumnType());
                    }
                    catch (Exception e)
                    {
                        e.printStackTrace();
                    }
                }
                else if (field_type.isEnum())
                {
                    if (!bFirst)
                        result.append(",");
                    result.append("enum");
                    bFirst = false;
                }
                else if (field_type.equals(byte[].class))
                {
                    //TODO: handles 'bytes' in c++ layer
                    if (!bFirst)
                        result.append(",");
                    result.append("bytes");
                    bFirst = false;
                }
                else if (field_type.equals(ArrayList.class))
                {
                    if (!bFirst)
                        result.append(",");
                    bFirst = false;
                    ParameterizedType myType = ((ParameterizedType) field.getGenericType());
                    Class<?> typeArg = getTypeClass(myType.getActualTypeArguments()[0]);
                    if (Model.class.isAssignableFrom(typeArg))
                    {
                        result.append("list." + Orm.getModelName(typeArg));
                    }
                    else if (String.class.isAssignableFrom(typeArg))
                    {
                        result.append("list.String");
                    }
                }
                else if (field_type.equals(HashMap.class))
                {
                    if (!bFirst)
                        result.append(",");
                    bFirst = false;
                    result.append("map");
                }
                else if (Model.class.isAssignableFrom(field_type))
                {
                    if (!bFirst)
                        result.append(",");
                    bFirst = false;
                    result.append("model." + Orm.getModelName(field_type));
                }
                else
                {
                    throw new IllegalArgumentException("Type is not supported: " + field_type.toString());
                }
            }
        }

        return result.toString();
    }

    /**
     * Returns a comma separated list of annotations for each field.
     *
     * @param clazz - The Model class.
     * @return - The resulting String.
     */
    @SuppressLint("DefaultLocale")
    public static String getColumnAnnotations(Class clazz)
    {
        StringBuilder result = new StringBuilder();
        boolean bFirst = true;
        Method[] methods = Persistent.class.getDeclaredMethods();

        List<Field> fields = ModelFieldCache.getInstance().getFields(clazz);
        for (Field field : fields)
        {
            Persistent persistent = field.getAnnotation(Persistent.class);
            if ((null != persistent) && (!persistent.joinedField()) && (persistent.inDb()))
            {
                boolean bFirstMethod = true;

                if (!bFirst)
                    result.append(",");

                for (Method method : methods)
                {
                    try
                    {
                        Object value = method.invoke(persistent, (Object[]) null);

                        if (!bFirstMethod)
                            result.append(':');
                        bFirstMethod = false;

                        if (method.getReturnType().equals(boolean.class))
                        {
                            result.append(method.getName());
                            result.append('=');
                            result.append(((boolean) value) ? '1' : '0');
                        }
                        else
                        {
                            result.append(method.getName());
                            result.append('=');
                            result.append(value.toString());
                        }
                    }
                    catch (IllegalAccessException e)
                    {
                        //e.printStackTrace();
                    }
                    catch (InvocationTargetException e)
                    {
                        //e.printStackTrace();
                    }
                }

                bFirst = false;
            }
        }

        //Timber.e(String.format("[getColumnAnnotations] %s - %s", clazz.getName(), result.toString()));
        return result.toString();
    }

    /**
     * Gets the column names as a <code>String</code> array.
     *
     * @param clazz   - The Model class.
     * @param bDbOnly - If true, only Persisted fields will be processed.
     * @return - String array.
     */
    public static String[] getColumnArray(Class clazz, boolean bDbOnly)
    {
        return getColumnArray(clazz, bDbOnly, false);
    }

    /**
     * Gets the column names as a <code>String</code> array.
     *
     * @param clazz      - The Model class.
     * @param bDbOnly    - If true, only Persisted fields will be processed.
     * @param bFullNames - If true the table name will be prefixed to the values.
     * @return - String array.
     */
    public static String[] getColumnArray(Class<? extends Model> clazz, boolean bDbOnly, boolean bFullNames)
    {
        ArrayList<String> result = new ArrayList<>();
        String table = Orm.getModelName(clazz) + ".";
        List<Field> fields = ModelFieldCache.getInstance().getFields(clazz);

        for (Field field : fields)
        {
            Persistent persistent = field.getAnnotation(Persistent.class);
            if ((null != persistent) && (!persistent.joinedField()))
            {
                boolean bQueryType = !TextUtils.isEmpty(persistent.query());
                if (!bDbOnly || (persistent.inDb() && (!bQueryType)))
                {
                    String name = field.getName();

                    if (persistent.pk())
                    {
                        name = ORMContentProvider.PRIMARY_TABLE_KEY_ALIAS;
                    }

                    Class<?> field_type = field.getType();
                    if (field_type.equals(String.class))
                    {
                        if (bFullNames)
                        {
                            result.add(table + name);
                        }
                        else
                        {
                            result.add(name);
                        }
                    }
                    else if (field_type.equals(Long.class) || field_type.equals(long.class))
                    {
                        if (bFullNames)
                        {
                            result.add(table + name);
                        }
                        else
                        {
                            result.add(name);
                        }
                    }
                    else if (field_type.equals(Integer.class) || field_type.equals(int.class))
                    {
                        if (bFullNames)
                        {
                            result.add(table + name);
                        }
                        else
                        {
                            result.add(name);
                        }
                    }
                    else if (field_type.equals(Double.class) || field_type.equals(double.class))
                    {
                        if (bFullNames)
                        {
                            result.add(table + name);
                        }
                        else
                        {
                            result.add(name);
                        }
                    }
                    else if (field_type.equals(Float.class) || field_type.equals(float.class))
                    {
                        if (bFullNames)
                        {
                            result.add(table + name);
                        }
                        else
                        {
                            result.add(name);
                        }
                    }
                    else if (field_type.equals(Boolean.class) || field_type.equals(boolean.class))
                    {
                        if (bFullNames)
                        {
                            result.add(table + name);
                        }
                        else
                        {
                            result.add(name);
                        }
                    }
                    else if (ModelBasicType.class.isAssignableFrom(field_type))
                    {
                        if (bFullNames)
                        {
                            result.add(table + name);
                        }
                        else
                        {
                            result.add(name);
                        }
                    }
                    else if (field_type.isEnum())
                    {
                        if (bFullNames)
                        {
                            result.add(table + name);
                        }
                        else
                        {
                            result.add(name);
                        }
                    }
                    else if (field_type.equals(byte[].class))
                    {
                        if (bFullNames)
                        {
                            result.add(table + name);
                        }
                        else
                        {
                            result.add(name);
                        }
                    }
                    else if (field_type.equals(ArrayList.class))
                    {
                        ParameterizedType myType = ((ParameterizedType) field.getGenericType());
                        Class<?> typeArg = getTypeClass(myType.getActualTypeArguments()[0]);
                        if (Model.class.isAssignableFrom(typeArg))
                        {
                            if (bFullNames)
                            {
                                result.add(table + name);
                            }
                            else
                            {
                                result.add(name);
                            }
                        }
                        else if (String.class.isAssignableFrom(typeArg))
                        {
                            if (bFullNames)
                            {
                                result.add(table + name);
                            }
                            else
                            {
                                result.add(name);
                            }
                        }
                    }
                    else if (field_type.equals(HashMap.class))
                    {
                        if (bFullNames)
                        {
                            result.add(table + name);
                        }
                        else
                        {
                            result.add(name);
                        }
                    }
                    else if (Model.class.isAssignableFrom(field_type))
                    {
                        if (bFullNames)
                        {
                            result.add(table + name);
                        }
                        else
                        {
                            result.add(name);
                        }
                    }
                    else
                    {
                        throw new IllegalArgumentException("Type is not supported: " + field_type.toString());
                    }
                }
            }
        }

        String[] resultArr = new String[result.size()];
        return result.toArray(resultArr);
    }

    /**
     * Compares the <code>Cursor</code> fields with the Model fields and returns an alter statement
     * for each field that has been added to the Model (that wasn't in the Cursor).
     *
     * @param clazz  - The Model class.
     * @param cursor - The Cursor.
     * @return - List of Strings.
     * @throws IllegalAccessException
     * @throws InstantiationException
     */
    public static ArrayList<String> getAlter(Class clazz, Cursor cursor) throws IllegalAccessException, InstantiationException
    {
        ArrayList<String> result = new ArrayList<>();
        Object defaults = clazz.newInstance();

        List<Field> fields = ModelFieldCache.getInstance().getFields(clazz);
        for (Field field : fields)
        {
            Persistent persistent = field.getAnnotation(Persistent.class);
            if ((null != persistent) && (!persistent.joinedField()) && (persistent.inDb()))
            {
                String name = field.getName();
                int col = cursor.getColumnIndex(name);

                // column missing??
                if (col < 0)
                {
                    Object value = Reflection.getFieldValue(defaults, field);
                    Class<?> field_type = field.getType();
                    if (field_type.equals(String.class))
                    {
                        result.add(String.format("ADD %s BLOB %s DEFAULT '%s'", name, persistent.appDb(), (String) value));
                    }
                    else if (field_type.equals(Long.class) || field_type.equals(long.class))
                    {
                        result.add(String.format("ADD %s INTEGER %s DEFAULT '%s'", name, persistent.appDb(), ((Long) value).toString()));
                    }
                    else if (field_type.equals(Integer.class) || field_type.equals(int.class))
                    {
                        result.add(String.format("ADD %s INTEGER %s DEFAULT '%s'", name, persistent.appDb(), ((Integer) value).toString()));
                    }
                    else if (field_type.equals(Double.class) || field_type.equals(double.class))
                    {
                        result.add(String.format("ADD %s REAL %s DEFAULT '%s'", name, persistent.appDb(), ((Double) value).toString()));
                    }
                    else if (field_type.equals(Float.class) || field_type.equals(float.class))
                    {
                        result.add(String.format("ADD %s REAL %s DEFAULT '%s'", name, persistent.appDb(), ((Float) value).toString()));
                    }
                    else if (field_type.equals(Boolean.class) || field_type.equals(boolean.class))
                    {
                        result.add(String.format("ADD %s INTEGER %s DEFAULT '%s'", name, persistent.appDb(), ((Boolean) value).toString()));
                    }
                    else if (ModelBasicType.class.isAssignableFrom(field_type))
                    {
                        result.add(((ModelBasicType) value).getAlter(persistent, name));
                    }
                    else if (field_type.isEnum())
                    {
                        result.add(String.format("ADD %s TEXT %s DEFAULT '%s'", name, persistent.appDb(), getEnumValue(field, value)));
                    }
                    else if (field_type.equals(byte[].class))
                    {
                        result.add(String.format("ADD %s BLOB %s DEFAULT '%s'", name, persistent.appDb(), (byte[]) value));
                    }
                    else if (field_type.equals(ArrayList.class))
                    {
                        ParameterizedType myType = ((ParameterizedType) field.getGenericType());
                        Class<?> typeArg = getTypeClass(myType.getActualTypeArguments()[0]);
                        if (Model.class.isAssignableFrom(typeArg))
                        {
                            result.add(String.format("ADD %s TEXT %s DEFAULT ''", name, persistent.appDb()));
                        }
                        else if (String.class.isAssignableFrom(typeArg))
                        {
                            result.add(String.format("ADD %s TEXT %s DEFAULT ''", name, persistent.appDb()));
                        }
                    }
                    else if (field_type.equals(HashMap.class))
                    {
                        result.add(String.format("ADD %s TEXT %s DEFAULT ''", name, persistent.appDb()));
                    }
                    else if (Model.class.isAssignableFrom(field_type))
                    {
                        result.add(String.format("ADD %s BLOB %s DEFAULT '%s'", name, persistent.appDb(), (String) value));
                    }
                    else
                    {
                        throw new IllegalArgumentException("Type is not supported: " + field_type.toString());
                    }
                }
            }
        }

        return result;
    }

    public static ArrayList<String> getMigrate(Class clazz, Cursor cursor)
    {
        ArrayList<String> result = new ArrayList<>();

        List<Field> fields = ModelFieldCache.getInstance().getFields(clazz);
        Collections.sort(fields, (lhs, rhs) -> (lhs.getName().compareTo(rhs.getName())));
        for (Field field : fields)
        {
            Persistent persistent = field.getAnnotation(Persistent.class);
            if ((null != persistent) && (!persistent.joinedField()) && (persistent.inDb()))
            {
                String name = field.getName();

                if (!name.contentEquals(COLUMN_PRIMARY_KEY))
                {
                    int col = cursor.getColumnIndex(name);

                    // column exists?
                    if (col >= 0)
                    {
                        Class<?> field_type = field.getType();
                        if (field_type.equals(String.class))
                        {
                            result.add(name);
                        }
                        else if (field_type.equals(Long.class) || field_type.equals(long.class))
                        {
                            result.add(name);
                        }
                        else if (field_type.equals(Integer.class) || field_type.equals(int.class))
                        {
                            result.add(name);
                        }
                        else if (field_type.equals(Double.class) || field_type.equals(double.class))
                        {
                            result.add(name);
                        }
                        else if (field_type.equals(Float.class) || field_type.equals(float.class))
                        {
                            result.add(name);
                        }
                        else if (field_type.equals(Boolean.class) || field_type.equals(boolean.class))
                        {
                            result.add(name);
                        }
                        else if (ModelBasicType.class.isAssignableFrom(field_type))
                        {
                            result.add(name);
                        }
                        else if (field_type.isEnum())
                        {
                            result.add(name);
                        }
                        else if (field_type.equals(byte[].class))
                        {
                            result.add(name);
                        }
                        else if (field_type.equals(ArrayList.class))
                        {
                            ParameterizedType myType = ((ParameterizedType) field.getGenericType());
                            Class<?> typeArg = getTypeClass(myType.getActualTypeArguments()[0]);
                            if (Model.class.isAssignableFrom(typeArg))
                            {
                                result.add(name);
                            }
                            else if (String.class.isAssignableFrom(typeArg))
                            {
                                result.add(name);
                            }
                        }
                        else if (field_type.equals(HashMap.class))
                        {
                            result.add(name);
                        }
                        else if (Model.class.isAssignableFrom(field_type))
                        {
                            result.add(name);
                        }
                        else
                        {
                            throw new IllegalArgumentException("Type is not supported: " + field_type.toString());
                        }
                    }
                }
            }
        }

        return result;
    }

    private static Class<?> getTypeClass(Type type)
    {
        if (type instanceof Class)
        {
            return (Class<?>) type;
        }
        else if (type instanceof ParameterizedType)
        {
            ParameterizedType pType = (ParameterizedType) type;
            Type owner = pType.getOwnerType();
            if (owner != null)
            {
                return getTypeClass(owner);
            }
            else
            {
                return getTypeClass(pType.getRawType());
            }
        }
        else if (type instanceof WildcardType)
        {
            WildcardType wType = (WildcardType) type;
            Type[] upperBounds = wType.getUpperBounds();
            for (Type bound : upperBounds)
            {
                Class<?> cls = getTypeClass(bound);
                if (cls != null)
                {
                    return cls;
                }
            }
        }
        return null;
    }

    private void parcel(Parcel dest, int flags)
    {
        List<Field> fields = ModelFieldCache.getInstance().getFields(((Object) this).getClass());
        for (Field field : fields)
        {
            Object value = Reflection.getFieldValue(this, field);
            Class<?> field_type = field.getType();
            if (null != value)
            {
                // flag item exists.
                dest.writeByte((byte) 1);
                if (field_type.equals(String.class))
                {
                    dest.writeString((String) value);
                }
                else if (field_type.equals(Long.class) || field_type.equals(long.class))
                {
                    dest.writeLong((Long) value);
                }
                else if (field_type.equals(Integer.class) || field_type.equals(int.class))
                {
                    dest.writeInt((Integer) value);
                }
                else if (field_type.equals(Double.class) || field_type.equals(double.class))
                {
                    dest.writeDouble((Double) value);
                }
                else if (field_type.equals(Float.class) || field_type.equals(float.class))
                {
                    dest.writeFloat((Float) value);
                }
                else if (field_type.equals(Boolean.class) || field_type.equals(boolean.class))
                {
                    dest.writeInt((Integer) ((Boolean) value ? 1 : 0));
                }
                else if (ModelBasicType.class.isAssignableFrom(field_type))
                {
                    ((ModelBasicType) value).parcel(dest, flags);
                }
                else if (field_type.isEnum())
                {
                    dest.writeString(getEnumValue(field, value));
                }
                else if (field_type.equals(byte[].class))
                {
                    dest.writeInt(((byte[]) value).length);
                    dest.writeByteArray((byte[]) value);
                }
                else if (field_type.equals(ArrayList.class))
                {
                    ParameterizedType myType = ((ParameterizedType) field.getGenericType());
                    Class<?> typeArg = getTypeClass(myType.getActualTypeArguments()[0]);
                    if (Model.class.isAssignableFrom(typeArg))
                    {
                        ArrayList list = (ArrayList) value;
                        dest.writeInt(list.size());
                        for (Object o : list)
                        {
                            if (null != o)
                            {
                                Model m = (Model) o;
                                dest.writeParcelable((Parcelable) m, flags);
                            }
                        }
                    }
                    else
                    {
                        // Treat array list of Model objects as a String of comma separated values.
                        dest.writeList((List) value);
                    }
                }
                else if (field_type.equals(HashMap.class))
                {
                    dest.writeMap((Map) value);
                }
                else if (Model.class.isAssignableFrom(field_type))
                {
                    dest.writeParcelable((Parcelable) value, flags);
                }
                else
                {
                    throw new IllegalArgumentException("Type is not supported: " + field_type.toString());
                }
            }
            else
            {
                // flag item null.
                dest.writeByte((byte) 0);
            }
        }
    }

    protected void unparcel(Parcel source)
    {
        List<Field> fields = ModelFieldCache.getInstance().getFields(((Object) this).getClass());
        for (Field field : fields)
        {
            String name = field.getName();
            Class<?> field_type = field.getType();
            byte itemExists = source.readByte();
            if (itemExists > 0)
            {
                if (field_type.equals(String.class))
                {
                    Reflection.setFieldValue(this, field, source.readString());
                }
                else if (field_type.equals(Long.class) || field_type.equals(long.class))
                {
                    Reflection.setFieldValue(this, field, source.readLong());
                }
                else if (field_type.equals(Integer.class) || field_type.equals(int.class))
                {
                    Reflection.setFieldValue(this, field, (Integer) source.readInt());
                }
                else if (field_type.equals(Double.class) || field_type.equals(double.class))
                {
                    Reflection.setFieldValue(this, field, (Double) source.readDouble());
                }
                else if (field_type.equals(Float.class) || field_type.equals(float.class))
                {
                    Reflection.setFieldValue(this, field, (Float) source.readFloat());
                }
                else if (field_type.equals(Boolean.class) || field_type.equals(boolean.class))
                {
                    Reflection.setFieldValue(this, field, (Boolean) (source.readInt() == 1 ? Boolean.TRUE : Boolean.FALSE));
                }
                else if (ModelBasicType.class.isAssignableFrom(field_type))
                {
                    try
                    {
                        ModelBasicType o = (ModelBasicType) field_type.newInstance();
                        o.unparcel(source);
                        Reflection.setFieldValue(this, field, o);
                    }
                    catch (Exception e)
                    {
                        e.printStackTrace();
                    }
                }
                else if (field_type.isEnum())
                {
                    Reflection.setFieldEnumValue(this, field, source.readString());
                }
                else if (field_type.equals(byte[].class))
                {
                    int len = source.readInt();
                    byte[] data = new byte[len];
                    source.readByteArray(data);
                    Reflection.setFieldValue(this, field, data);
                }
                else if (field_type.equals(ArrayList.class))
                {
                    ParameterizedType myType = ((ParameterizedType) field.getGenericType());
                    Class<?> typeArg = getTypeClass(myType.getActualTypeArguments()[0]);
                    if (Model.class.isAssignableFrom(typeArg))
                    {
                        ArrayList list = new ArrayList();
                        Reflection.setFieldValue(this, name, list);
                        int count = source.readInt();
                        for (int i = 0; i < count; i++)
                        {
                            try
                            {
                                Model o = (Model) typeArg.newInstance();
                                o.unparcel(source);
                            }
                            catch (Exception e)
                            {
                                e.printStackTrace();
                            }
                        }
                    }
                    else
                    {
                        ArrayList list = new ArrayList();
                        source.readList(list, null);
                        Reflection.setFieldValue(this, name, list);
                    }
                }
                else if (field_type.equals(HashMap.class))
                {
                    HashMap map = new HashMap();
                    source.readMap(map, null);
                    Reflection.setFieldValue(this, name, map);
                }
                else if (Model.class.isAssignableFrom(field_type))
                {
                    Reflection.setFieldValue(this, name, source.readParcelable(null));
                }
                else
                {
                    //throw new IllegalArgumentException("Type is not supported: " + field_type.toString());
                }
            }
        }
    }

    /**
     * Copies fields from the supplied source.
     *
     * @param source - Model to copy from.
     */
    public void copy(Model source)
    {
        if (null != source)
        {
            List<Field> fields = ModelFieldCache.getInstance().getFields(((Object) this).getClass());
            for (Field field : fields)
            {
                Class<?> field_type = field.getType();
                if (field_type.equals(String.class))
                {
                    Reflection.setFieldValue(this, field, Reflection.getFieldValue(source, field));
                }
                else if (field_type.equals(Long.class) || field_type.equals(long.class))
                {
                    Reflection.setFieldValue(this, field, Reflection.getFieldValue(source, field));
                }
                else if (field_type.equals(Integer.class) || field_type.equals(int.class))
                {
                    Reflection.setFieldValue(this, field, (Integer) Reflection.getFieldValue(source, field));
                }
                else if (field_type.equals(Double.class) || field_type.equals(double.class))
                {
                    Reflection.setFieldValue(this, field, (Double) Reflection.getFieldValue(source, field));
                }
                else if (field_type.equals(Float.class) || field_type.equals(float.class))
                {
                    Reflection.setFieldValue(this, field, (Float) Reflection.getFieldValue(source, field));
                }
                else if (field_type.equals(Boolean.class) || field_type.equals(boolean.class))
                {
                    Reflection.setFieldValue(this, field, (Boolean) Reflection.getFieldValue(source, field));
                }
                else if (ModelBasicType.class.isAssignableFrom(field_type))
                {
                    Reflection.setFieldValue(this, field, Reflection.getFieldValue(source, field));
                }
                else if (field_type.isEnum())
                {
                    Reflection.setFieldEnumValue(this, field, (String) Reflection.getFieldValue(source, field));
                }
                else if (field_type.equals(byte[].class))
                {
                    Reflection.setFieldValue(this, field, (byte[]) Reflection.getFieldValue(source, field));
                }
                else if (field_type.equals(ArrayList.class))
                {
                    ParameterizedType myType = ((ParameterizedType) field.getGenericType());
                    Class<?> typeArg = getTypeClass(myType.getActualTypeArguments()[0]);
                    if (Model.class.isAssignableFrom(typeArg))
                    {
                        Reflection.setFieldValue(this, field, (ArrayList) Reflection.getFieldValue(source, field));
                    }
                    else if (String.class.isAssignableFrom(typeArg))
                    {
                        Reflection.setFieldValue(this, field, (ArrayList) Reflection.getFieldValue(source, field));
                    }
                }
                else if (field_type.equals(HashMap.class))
                {
                    Reflection.setFieldValue(this, field, (HashMap) Reflection.getFieldValue(source, field));
                }
                else if (Model.class.isAssignableFrom(field_type))
                {
                    Reflection.setFieldValue(this, field, Reflection.getFieldValue(source, field));
                }
                else
                {
                    throw new IllegalArgumentException("Type is not supported: " + field_type.toString());
                }
            }
        }
    }

    protected <T extends Model> List<String> getColumnNamesFromFieldNames(Class<T> modelClass)
    {
        List<String> columns = new ArrayList<>();
        List<Field> fields = ModelFieldCache.getInstance().getFields(((Object) this).getClass());
        //Reflection.getAllDeclaredNonStaticFields(modelClass);
        for (Field field : fields)
        {
            columns.add(field.getName());
        }
        return columns;
    }

    protected <T extends Model> List<Field> getColumnFieldsFromFieldNames(Class<T> modelClass)
    {
        return ModelFieldCache.getInstance().getFields(((Object) this).getClass());//
        // Reflection.getAllDeclaredNonStaticFields(modelClass);
    }

    public void read()
    {
        copy(ORMTable.getModel(this.getClass(), null, String.format("%s='%s'", getIdFieldName(), getId()), null, 0, 0));
    }

    public void delete()
    {
        deleted = true;
        save();
    }

    /**
     * Saves only the specified fields for this model...
     * This prevents overwriting items that are not in sync with the cache/db.
     */
    public void save(String... fieldsToSave)
    {
        saveChildren(null, false, fieldsToSave);
        saveThis(null, fieldsToSave);
    }

    /**
     * Save this model to the database.
     */
    public void save()
    {
        save(null, false);
    }

    /**
     * Conditionally save this model to the database.
     *
     * @param where             - The where clause for the query/save.
     * @param bSaveParentsFirst - select the save order - parent/children first.
     */
    public void save(String where, boolean bSaveParentsFirst)
    {
        if (bSaveParentsFirst)
        {
            saveThis(where);
            saveChildren(where, bSaveParentsFirst);
        }
        else
        {
            saveChildren(where, bSaveParentsFirst);
            saveThis(where);
        }
    }

    /**
     * Saves children of this model in to the database.
     *
     * @param where             - An optional 'where' clause.
     * @param bSaveParentsFirst - select the save order - parent/children first.
     */
    public void saveChildren(String where, boolean bSaveParentsFirst)
    {
        // Save children models...
        List<Field> fields = Reflection.getAllDeclaredNonStaticFields(((Object) this).getClass());
        for (Field field : fields)
        {
            Persistent persistent = null;
            try
            {
                persistent = field.getAnnotation(Persistent.class);
            }
            catch (Exception perr)
            {
                perr.printStackTrace();
            }

            if (null != persistent)
            {
                try
                {
                    Class<?> field_type = field.getType();

                    if (field_type.equals(ArrayList.class))
                    {
                        if (isNotFromParentOrReference(persistent))
                        {
                            Object value = Reflection.getFieldValue(this, field);

                            ParameterizedType myType = ((ParameterizedType) field.getGenericType());
                            Class<?> typeArg = getTypeClass(myType.getActualTypeArguments()[0]);
                            if (Model.class.isAssignableFrom(typeArg))
                            {
                                for (Object o : (ArrayList) value)
                                {
                                    if (null != o)
                                    {
                                        Model m = (Model) o;
                                        m.save(where, bSaveParentsFirst);
                                    }
                                }
                            }
                        }
                    }
                    else if (Model.class.isAssignableFrom(field_type))
                    {
                        if (isNotFromParentOrReference(persistent))
                        {
                            Object value = Reflection.getFieldValue(this, field);
                            if (null != value)
                            {
                                Model m = (Model) value;
                                m.save(where, bSaveParentsFirst);
                            }
                        }
                    }
                }
                catch (Exception e)
                {
                    e.printStackTrace();
                }
            }
        }
    }

    /**
     * Saves children of this model in to the database.
     *
     * @param where             - An optional 'where' clause.
     * @param bSaveParentsFirst - select the save order - parent/children first.
     */
    public void saveChildren(String where, boolean bSaveParentsFirst, String... fieldsToSave)
    {
        // Save children models...
        List<Field> fields = Reflection.getAllDeclaredNonStaticFields(((Object) this).getClass());
        for (Field field : fields)
        {
            if (ArrayUtils.contains(fieldsToSave, field.getName()))
            {
                Persistent persistent = null;
                try
                {
                    persistent = field.getAnnotation(Persistent.class);
                }
                catch (Exception perr)
                {
                    perr.printStackTrace();
                }

                if (null != persistent)
                {
                    try
                    {
                        Class<?> field_type = field.getType();

                        if (field_type.equals(ArrayList.class))
                        {
                            if (isNotFromParentOrReference(persistent))
                            {
                                Object value = Reflection.getFieldValue(this, field);

                                ParameterizedType myType = ((ParameterizedType) field.getGenericType());
                                Class<?> typeArg = getTypeClass(myType.getActualTypeArguments()[0]);
                                if (Model.class.isAssignableFrom(typeArg))
                                {
                                    for (Object o : (ArrayList) value)
                                    {
                                        if (null != o)
                                        {
                                            Model m = (Model) o;
                                            m.save(where, bSaveParentsFirst);
                                        }
                                    }
                                }
                            }
                        }
                        else if (Model.class.isAssignableFrom(field_type))
                        {
                            if (isNotFromParentOrReference(persistent))
                            {
                                Object value = Reflection.getFieldValue(this, field);
                                if (null != value)
                                {
                                    Model m = (Model) value;
                                    m.save(where, bSaveParentsFirst);
                                }
                            }
                        }
                    }
                    catch (Exception e)
                    {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    /**
     * Save the 'parent' this Model in to the database.
     *
     * @param where - An optional 'where' clause.
     */
    public void saveThis(String where)
    {
        // save main model.
        try
        {
            ORMTable.saveModel(this, where);

            Cached cached = getClass().getAnnotation(Cached.class);
            if (null != cached && cached.cached())
            {
                ORMDbCache.getInstance().updateModel(getClass(), this);
            }
        }
        catch (Exception e)
        {
            Timber.e(e, "An error occurred when saving the model to the database");
        }
    }

    /**
     * Save the 'parent' this Model with the selected fields only.. in to the database.
     *
     * @param where - An optional 'where' clause.
     * @param fieldsToSave - The list of fields to save.
     */
    public void saveThis(String where, String... fieldsToSave)
    {
        // save main model.
        try
        {
            ORMTable.saveModel(this, where, true, fieldsToSave);

            /* Don't touch the cache.
            Cached cached = getClass().getAnnotation(Cached.class);
            if (null != cached && cached.cached())
            {
                ORMDbCache.getInstance().updateModel(getClass(), this);
            }
            */
        }
        catch (Exception e)
        {
            Timber.e(e, "An error occurred when saving the model to the database");
        }
    }

    @NonNull
    @Override
    public String toString()
    {
        StringBuilder result = new StringBuilder();
        boolean bFirst = true;

        List<Field> fields = ModelFieldCache.getInstance().getFields(getClass());
        for (Field field : fields)
        {
            Persistent persistent = field.getAnnotation(Persistent.class);
            if (null != persistent)
            {
                String name = field.getName();
                Object value = Reflection.getFieldValue(this, field);

                if (!bFirst)
                    result.append(",");
                result.append(name);
                result.append("=");

                if (value instanceof Model && !isNotFromParentOrReference(persistent))
                {
                    result.append(((Model) value).getId());
                }
                else
                {
                    if (!(value instanceof String))
                    {
                        result.append(value);
                    }
                    else
                    {
                        result.append(((String) value).replaceAll("%", ""));
                    }
                }
                bFirst = false;
            }
        }

        return result.toString();
    }

    /**
     * Gets <code>Model</code> fields as a <code>Cursor</code> row. Useful when creating a
     * <code>MatrixCursor</code>.
     *
     * @param bDbOnly - If true only fields annotated with <code>Persistent</code> will be added.
     * @return - An array of Objects.
     */
    public Object[] getAsCursorRow(boolean bDbOnly)
    {
        ArrayList<Object> result = new ArrayList<>();

        List<Field> fields = ModelFieldCache.getInstance().getFields(((Object) this).getClass());
        //Reflection.getAllDeclaredNonStaticFields(((Object) this).getClass());
        for (Field field : fields)
        {
            Persistent persistent = field.getAnnotation(Persistent.class);
            if ((null != persistent) && (!persistent.joinedField()))
            {
                boolean bQueryType = !TextUtils.isEmpty(persistent.query());
                if (!bDbOnly || (persistent.inDb() && (!bQueryType)))
                {
                    //String name = field.getName();
                    Object value = Reflection.getFieldValue(this, field);
                    Class<?> field_type = field.getType();
                    if (null != value)
                    {
                        if (field_type.isEnum())
                        {
                            result.add(getEnumValue(field, value));//result.add(Enum.valueOf((Class<Enum>) field.getType(), ((Enum)value).name()).name());
                        }
                        else if (field_type.equals(Boolean.class) || field_type.equals(boolean.class))
                        {
                            result.add((Integer) (((Boolean) value) ? 1 : 0));
                        }
                        else if (ModelBasicType.class.isAssignableFrom(field_type))
                        {
                            result.add(((ModelBasicType) value).getAsCursorRow());
                        }
                        else if (field_type.equals(byte[].class))
                        {
                            result.add(value);
                        }
                        else if (field_type.equals(ArrayList.class))
                        {
                            // Treat array list of Model objects as a String of comma separated values.
                            //TODO: FIX THIS FOR LICENCE CLASSES ETC (NO DB)
                            ParameterizedType myType = ((ParameterizedType) field.getGenericType());
                            Class<?> typeArg = getTypeClass(myType.getActualTypeArguments()[0]);
                            if (Model.class.isAssignableFrom(typeArg))
                            {
                                String listValue = "";
                                for (Object o : (ArrayList) value)
                                {
                                    if (null != o)
                                    {
                                        Model m = (Model) o;
                                        if (TextUtils.isEmpty(listValue))
                                        {
                                            listValue = Character.toString((char) 1) + m.getId() + Character.toString((char) 1);
                                        }
                                        else
                                        {
                                            listValue += m.getId() + Character.toString((char) 1);
                                        }
                                    }
                                }
                                result.add(listValue);
                            }
                            else if (String.class.isAssignableFrom(typeArg))
                            {
                                String listValue = "";
                                for (Object o : (ArrayList) value)
                                {
                                    if (null != o)
                                    {
                                        String m = (String) o;
                                        if (TextUtils.isEmpty(listValue))
                                        {
                                            listValue = Character.toString((char) 1) + m + Character.toString((char) 1);
                                        }
                                        else
                                        {
                                            listValue += m + Character.toString((char) 1);
                                        }
                                    }
                                }
                                result.add(listValue);
                            }
                        }
                        else if (field_type.equals(HashMap.class))
                        {
                            Gson gson = new Gson();
                            String map = gson.toJson(value);
                            result.add(map);
                        }
                        else if (Model.class.isAssignableFrom(field_type))
                        {
                            Model m = (Model) value;
                            result.add(m.getId());
                        }
                        else
                        {
                            result.add(value);
                        }
                    }
                    else
                    {
                        result.add(null);
                    }
                }
            }
        }

        Object[] resultArr = new Object[result.size()];
        return result.toArray(resultArr);
    }

    private HashSet<String> getTreeClassNames()
    {
        HashSet<String> result = new HashSet<>();
        getTreeClassNames(((Object) this).getClass(), result);
        return result;
    }

    private void getTreeClassNames(HashSet<String> result)
    {
        getTreeClassNames(((Object) this).getClass(), result);
    }

    private static void getTreeClassNames(Class clazz, HashSet<String> result)
    {
        List<Field> fields = ModelFieldCache.getInstance().getFields(clazz);
        for (Field field : fields)
        {
            Class<?> field_type = field.getType();
            if (field_type.equals(ArrayList.class))
            {
                // Treat array list of Model objects as a String of comma separated values.
                //TODO: FIX THIS FOR LICENCE CLASSES ETC (NO DB)
                ParameterizedType myType = ((ParameterizedType) field.getGenericType());
                Class<?> typeArg = getTypeClass(myType.getActualTypeArguments()[0]);
                if (Model.class.isAssignableFrom(typeArg))
                {
                    Persistent persistent = getPersistent(field);
                    if (isNotFromReference(persistent))
                    {
                        result.add(typeArg.getSimpleName());
                    }

                    if (isNotFromParent(persistent))
                    {
                        getTreeClassNames(typeArg, result);
                    }
                }
            }
            else if (Model.class.isAssignableFrom(field_type))
            {
                Persistent persistent = getPersistent(field);
                if (isNotFromReference(persistent))
                {
                    result.add(field_type.getSimpleName());
                }

                if (isNotFromParent(persistent))
                {
                    getTreeClassNames(field_type, result);
                }
            }
        }
    }

    private static Persistent getPersistent(Field field)
    {
        try
        {
            return field.getAnnotation(Persistent.class);
        }
        catch (Exception perr)
        {
            perr.printStackTrace();
        }

        return null;
    }

    private static boolean isNotFromParent(Field field)
    {
        return isNotFromParent(getPersistent(field));
    }

    private static boolean isNotFromParent(Persistent persistent)
    {
        if (null != persistent)
        {
            return ((!persistent.fromParent()) && (!persistent.fromParentValue()));
        }

        return true;
    }

    private static boolean isNotFromReference(Field field)
    {
        return isNotFromReference(getPersistent(field));
    }

    private static boolean isNotFromReference(Persistent persistent)
    {
        if (null != persistent)
        {
            return (!persistent.asReference());
        }

        return true;
    }

    private static boolean isNotFromParentOrReference(Field field)
    {
        return isNotFromParentOrReference(getPersistent(field));
    }

    private static boolean isNotFromParentOrReference(Persistent persistent)
    {
        if (null != persistent)
        {
            return ((!persistent.fromParent()) && (!persistent.fromParentValue()) && (!persistent.asReference()));
        }

        return true;
    }

    private static String getEnumValue(Field field, Object value)
    {
        try
        {
            Method m = field.getType().getMethod("name", null);
            return  (String)m.invoke(value, null);
        }
        catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException ex)
        {

        }

        return null;
    }
}
